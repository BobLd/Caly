using Caly.Pdf.Models;
using UglyToad.PdfPig.Content;
using UglyToad.PdfPig.Core;
using UglyToad.PdfPig.DocumentLayoutAnalysis;
using UglyToad.PdfPig.DocumentLayoutAnalysis.WordExtractor;

namespace Caly.Pdf.Layout
{
    /*
     * From PdfPig
     */

    /// <summary>
    /// Nearest Neighbour Word Extractor.
    /// This implementation leverages bounding boxes.
    /// </summary>
    public sealed class CalyNNWordExtractor
    {
        private readonly CalyNNWordExtractorOptions options;

        /// <summary>
        /// Create an instance of Nearest Neighbour Word Extractor, <see cref="CalyNNWordExtractor"/>.
        /// </summary>
        public static readonly CalyNNWordExtractor Instance = new();

        /// <summary>
        /// Create an instance of Nearest Neighbour Word Extractor using default options values.
        /// </summary>
        public CalyNNWordExtractor() : this(new CalyNNWordExtractorOptions())
        {
        }

        /// <summary>
        /// Create an instance of Nearest Neighbour Word Extractor using options values.
        /// </summary>
        /// <param name="options">The <see cref="NearestNeighbourWordExtractor.NearestNeighbourWordExtractorOptions"/> to use.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public CalyNNWordExtractor(CalyNNWordExtractorOptions options)
        {
            this.options = options ?? throw new ArgumentNullException(nameof(options));
        }

        /// <summary>
        /// Get the words.
        /// </summary>
        /// <param name="letters">The page's letters to group into <see cref="Word"/>s.</param>
        /// <param name="cancellationToken"></param>
        /// <returns>The <see cref="Word"/>s generated by the nearest neighbour method.</returns>
        public IEnumerable<PdfWord> GetWords(IReadOnlyList<PdfLetter> letters, CancellationToken cancellationToken)
        {
            if (letters == null || letters.Count == 0)
            {
                return Array.Empty<PdfWord>();
            }

            var parallelOptions = new ParallelOptions()
            {
                MaxDegreeOfParallelism = options.MaxDegreeOfParallelism,
                CancellationToken = cancellationToken
            };

            if (options.GroupByOrientation)
            {
                // axis aligned
                var lo = letters.ToLookup(x => x.TextOrientation);

                var horizontal = GetWords(lo[TextOrientation.Horizontal].ToArray(),
                     options.MaximumDistance, options.DistanceMeasureAA, options.FilterPivot,
                     options.Filter, parallelOptions);

                var rotate270 = GetWords(lo[TextOrientation.Rotate270].ToArray(),
                     options.MaximumDistance, options.DistanceMeasureAA, options.FilterPivot,
                     options.Filter, parallelOptions);

                var rotate180 = GetWords(lo[TextOrientation.Rotate180].ToArray(),
                    options.MaximumDistance, options.DistanceMeasureAA, options.FilterPivot,
                    options.Filter, parallelOptions);

                var rotate90 = GetWords(lo[TextOrientation.Rotate90].ToArray(),
                    options.MaximumDistance, options.DistanceMeasureAA, options.FilterPivot,
                    options.Filter, parallelOptions);

                // not axis aligned
                var other = GetWords(lo[TextOrientation.Other].ToArray(),
                    options.MaximumDistance, options.DistanceMeasure, options.FilterPivot,
                    options.Filter, parallelOptions);

                return horizontal.Concat(rotate270).Concat(rotate180).Concat(rotate90).Concat(other);
            }
            else
            {
                return GetWords(letters,
                    options.MaximumDistance, options.DistanceMeasure, options.FilterPivot,
                    options.Filter, parallelOptions);
            }
        }

        /// <summary>
        /// Gets the words.
        /// </summary>
        /// <param name="letters">The letters in the page.</param>
        /// <param name="maxDistanceFunction">The function that determines the maximum distance between two letters (start and end base line points),
        /// e.g. Max(GlyphRectangle.Width) x 20%.
        /// <para>If the distance between the two letters is greater, a new word will be created.</para></param>
        /// <param name="distMeasure">The distance measure between two letters (start and end base line points),
        /// e.g. the Manhattan distance.</param>
		/// <param name="filterPivotFunction"></param>
        /// <param name="filterFunction">Function used to filter out connection between letters, e.g. check if the letters have the same color.
        /// <para>If the function returns false, a new word will be created.</para></param>
        /// <param name="parallelOptions">Sets the maximum number of concurrent tasks enabled.
        /// <para>A positive property value limits the number of concurrent operations to the set value.
        /// If it is -1, there is no limit on the number of concurrently running operations.</para></param>
        private static IEnumerable<PdfWord> GetWords(IReadOnlyList<PdfLetter> letters,
            Func<PdfLetter, PdfLetter, double> maxDistanceFunction, Func<PdfPoint, PdfPoint, double> distMeasure,
            Func<PdfLetter, bool> filterPivotFunction,
            Func<PdfLetter, PdfLetter, bool> filterFunction, ParallelOptions parallelOptions)
        {
            if (letters == null || letters.Count == 0)
            {
                yield break;
            }

            var groupedLetters = CalyClustering.NearestNeighbours(letters,
                distMeasure, maxDistanceFunction,
                l => l.EndBaseLine, l => l.StartBaseLine,
                filterPivotFunction,
                filterFunction,
                parallelOptions);

            foreach (var g in groupedLetters)
            {
                yield return new PdfWord(g);
            }
        }

        /// <summary>
        /// Nearest neighbour word extractor options.
        /// </summary>
        public class CalyNNWordExtractorOptions
        {
            /// <summary>
            /// <inheritdoc/>
            /// Default value is -1.
            /// </summary>
            public int MaxDegreeOfParallelism { get; set; } = -1;

            /// <summary>
            /// The maximum distance between two letters (start and end base line points) within the same word, as a function of the two letters.
            /// <para>If the distance between the two letters is greater than this maximum, they will belong to different words.</para>
            /// <para>Default value is 20% of the Max(Width, PointSize) of both letters. If <see cref="TextOrientation"/> is Other, this distance is doubled.</para>
            /// </summary>
            public Func<PdfLetter, PdfLetter, double> MaximumDistance { get; set; } = (l1, l2) =>
            {
                double maxDist = Math.Max(Math.Max(Math.Max(
                    Math.Abs(l1.BoundingBox.Width),
                    Math.Abs(l2.BoundingBox.Width)),
                    l1.PointSize), l2.PointSize) * 0.2;

                if (l1.TextOrientation == TextOrientation.Other || l2.TextOrientation == TextOrientation.Other)
                {
                    return 2.0 * maxDist;
                }
                return maxDist;
            };

            /// <summary>
            /// The default distance measure used between two letters (start and end base line points).
            /// <para>Default value is the Euclidean distance.</para>
            /// </summary>
            public Func<PdfPoint, PdfPoint, double> DistanceMeasure { get; set; } = Distances.Euclidean;

            /// <summary>
            /// The distance measure used between two letters (start and end base line points) with axis aligned <see cref="TextOrientation"/>.
            /// <para>Only used if <see cref="GroupByOrientation"/> is set to <c>true</c>.</para>
            /// <para>Default value is the Manhattan distance.</para>
            /// </summary>
            public Func<PdfPoint, PdfPoint, double> DistanceMeasureAA { get; set; } = Distances.Manhattan;

            /// <summary>
            /// Function used to filter out connection between letters, e.g. check if the letters have the same color.
            /// If the function returns <c>false</c>, letters will belong to different words.
            /// <para>Default value checks whether the neighbour is a white space or not. If it is the case, it returns <c>false</c>.</para>
            /// </summary>
            public Func<PdfLetter, PdfLetter, bool> Filter { get; set; } = (_, l2) => !l2.Value.Span.IsWhiteSpace();

            /// <summary>
            /// Function used prior searching for the nearest neighbour. If return false, no search will be done.
            /// <para>Default value checks whether the current letter is a white space or not. If it is the case, it returns false and no search is done.</para>
            /// </summary>
            public Func<PdfLetter, bool> FilterPivot { get; set; } = l => !l.Value.Span.IsWhiteSpace();

            /// <summary>
            /// If <c>true</c>, letters will be grouped by <see cref="TextOrientation"/> before processing.
            /// The <see cref="DistanceMeasureAA"/> will be used on axis aligned letters, and the <see cref="DistanceMeasure"/> on others.
            /// <para>If <c>false</c>, <see cref="DistanceMeasure"/> will be used for all letters, and <see cref="DistanceMeasureAA"/> won't be used.</para>
            /// <para>Default value is true.</para>
            /// </summary>
            public bool GroupByOrientation { get; set; } = true;
        }
    }
}
